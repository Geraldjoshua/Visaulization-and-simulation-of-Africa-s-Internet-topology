<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <style>
        * {
           font-family: "Helvetica Neue";
        }

        svg {
            /*width: 100%;
            height: 100%;
            position: center;*/
            background-color: #2B65EC;
        }
        p {
           font-size: 0.85em;
        }
        .country {
            fill: #cccccc;
            stroke: #333333;
            stroke-width: 0.5;
        }
        .selected {
            fill: yellow;
        }
        .asn-label {
            font-size: 10px;
        }
        .hidden {
            display: none;
        }
        div.tooltip {
            color: #222; 
            background: #fff; 
            border-radius: 3px; 
            box-shadow: 0px 0px 2px 0px #a6a6a6; 
            padding: .2em; 
            text-shadow: #f5f5f5 0 1px 0;
            opacity: 0.9; 
            position: absolute;
        </style>
        
    </head>
    <body>
        <div id="map"></div>
        <div class="tooltip"></div>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.2.2/d3.min.js"></script>
		<script src="https://d3js.org/topojson.v1.min.js"></script> 
        <!-- <script src="https://unpkg.com/topojson@3/dist/topojson.min.js"></script> -->
        <script>
            var margin = { top:50, left:50, right:50, bottom:50},
            height = 600 - margin.top - margin.bottom,
            width = 1600 - margin.left - margin.right;

        var svg = d3.select("#map")
                .append("svg")
                .attr("height",height+margin.top+margin.bottom)
                .attr("width", width + margin.left+ margin.right)
                .append("g")
                .attr("transform","translate("+margin.left+","+margin.top + ")");
        var tooltip = d3.select("div.tooltip");
        d3.queue()
            .defer(d3.json,"static/world.json")
            .defer(d3.csv, "static/world-country-names.csv")
            .defer(d3.csv,"static/asn_loc.csv")
            .defer(d3.csv,"static/asn_links.csv")
            .await(ready)

        //create a new projection using mercator(geoMercator)
        //translate btn round globe to flat globe
        var projection = d3.geoMercator()
            .translate([width/2,height/2])
            .scale(150)

        //create path(geoPath)
        //shape is build from points this is like a line generator
        var path = d3.geoPath()
            .projection(projection)


        // Create data: coordinates of start and end
        var link = [
      {type: "LineString", coordinates: [[100, 60], [-60, -30],[-10, 10],[35, -9]]},
      {type: "LineString", coordinates: [[10, -20], [-60, -30]]},
      {type: "LineString", coordinates: [[10, -20], [130, -30]]}
    ]
        //function ready(error,data,tracerti){
        function ready(error,data,names,tracerti,asnlinks){
            console.log(data)

            //converting raw geo data into usable geo data
            //find what you wanna extract
            //.features allows one to get the features out of that topojson
            var countries1 = topojson.feature(data, data.objects.countries).features
            countries = countries1.filter(function(d) {
            return names.some(function(n) {
              if (d.id == n.id) return d.name = n.name;
            })});

            //add path for each country shapes ->path
            //.country is a path
            svg.selectAll(".country")
                .data(countries)  //binding our countries
                .enter().append("path") //path for every single country
                .attr("class","country") //set it to be class of country
                .attr("d",path) //attribute for countries to show up list of coordinates (d)
                .on("mouseover",function(d,i){
                    d3.select(this).classed("selected",true)
                    return tooltip.style("hidden", false).html(d.name);
                })
                .on("mousemove",function(d){
                    tooltip.classed("hidden", false)
                           .style("top", (d3.event.pageY) + "px")
                           .style("left", (d3.event.pageX + 10) + "px")
                           .html(d.name);
                })
                .on("mouseout",function(d,i){
                    d3.select(this).classed("selected",false)
                    tooltip.classed("hidden", true);
                });


            // //add links
            // svg.selectAll(".links")
            //     .data(link)
            //     .enter()
            //     .append("path")
            //         .attr("d",function (d) {
            //             console.log(d)
            //             return path(d)
            //         })
            //         .style("fill", "none")
            //         .style("stroke", "orange")
            //         .style("stroke-width", 2)

            //add the connections between asns
            svg.selectAll(".asn-circles") //call them asn circles
                .data(tracerti)
                .enter().append("circle") // circle like
                .attr("r",1.5) // radius
                //circle has a cx and a cy (lat and long)
                //since they are different for each throw a function
                .attr("cx",function(d) {
                    //console.log(d)
                    var coord = projection([d.Longitude,d.Latitude]) //feeding lat and long to mecator to convert it to somethin we can see
                    return coord[0];
                })
                .attr("cy",function (d) {
                    var coord = projection([d.Longitude,d.Latitude]) //feeding lat and long to mecator to convert it to somethin we can see
                    return coord[1];
                })
                .append("title")
                .text(function(d) { return d.ASN; });

            // svg.selectAll(".asn-label") //call them asn circles
            //     .data(tracerti)
            //     .enter().append("text") // circle like
            //     .attr("class","asn-label")
            //     //circle has a cx and a cy (lat and long)
            //     //since they are different for each throw a function
            //     .attr("x",function(d) {
            //         //console.log(d)
            //         var coord = projection([d.Longitude,d.Latitude]) //feeding lat and long to mecator to convert it to somethin we can see
            //         return coord[0];
            //     })
            //     .attr("y",function (d) {
            //         var coord = projection([d.Longitude,d.Latitude]) //feeding lat and long to mecator to convert it to somethin we can see
            //         return coord[1];
            //     })
            //     .on('mouseover',function(d) {
            //            d3.select(this).
            //         })
            //     })

            //     .attr("dx",5) //offset
            //     .attr("dy",2)


            var d = tracerti
            var l = asnlinks
            var links = [];
            var ASN_loc = [];
            for (x of d) {
                asn = {Name: x.ASN, Long: x.Longitude, Lat: x.Latitude}
                ASN_loc.push(asn)

            }
            var counter = 0;
            source = []
            target = []
            for( x of l){
                for(p of ASN_loc){
                    if (p.Name == x.Source) {
                        source = [p.Long, p.Lat]
                        counter += 1;
                    }
                    if (p.Name == x.Target) {
                        target = [p.Long, p.Lat]
                        counter += 1;
                    }
                    if (counter==2){
                        topush = {type: "LineString", coordinates: [source, target]}
                        links.push(topush)
                        counter = 0
                        break
                    }

                }
                counter = 0


            }
           svg.selectAll(".links")
                .data(links)
                .enter()
                .append("path")
                    .attr("d",function (d) {
                        //console.log(d)
                        return path(d)
                    })
                    //.attr("moveTo")
                    .style("fill", "none")
                    .style("stroke", "red")
                    .style("stroke-width", 0.5)
                //.call(d3.drag().on("drag", move))
                .call(d3.drag().on("drag", dragged))
                // .call(d3.drag()
                //     .on('start', dragstarted)
                //     .on('drag', dragged)
                //     .on('end', dragended));

            // // drag nodes
            // function dragstarted(d) {
            //   //if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            //   d.fx = d.x;
            //   d.fy = d.y;
            // }

            // function dragged(d) {
            //   d.fx = d3.event.x;
            //   d.fy = d3.event.y;
            //   fix_nodes(d);
            // }

            // function dragended(d) {
            //   //if (!d3.event.active) simulation.alphaTarget(0);
            //   d.fx = d.x;
            //   d.fy = d.y;
            // }

            // // Preventing other nodes from moving while dragging one node
            // function fix_nodes(this_node) {
            //   node.each(function(d) {
            //     if (this_node != d) {
            //       d.fx = d.x;
            //       d.fy = d.y;
            //     }
            //   });
            // }

            // function move(d){
            //     var d = d3.path()
            //         .moveTo(0,0)
            //         .lineTo(d3.event.dx,0)
            //         .lineTo(d3.event.x,10)
            //         .lineTo(20,10)
            //     path.attr('d',d.toString());
            //     }


            function dragged(d) {

                  // Current position:
                  this.x = this.x || 0;
                  this.y = this.y || 0;
                  // Update thee position with the delta x and y applied by the drag:
                  this.x += d3.event.dx;
                  this.y += d3.event.dy;

                  // Apply the translation to the shape:
                  d3.select(this)
                    .attr("transform", "translate(" + this.x + "," + this.y + ")");
                }


        }
        </script>
    </body>








<!-- <!DOCTYPE html>
<meta charset="utf-8">
<style>

svg {
  background-color: lavender;
  border: 1px solid black;
}

path {
  fill: oldlace;
  stroke: #666;
  stroke-width: .5px;
}

</style>
<body>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>
<script>

var width = 600,
    height = 400,
    rotate = 60,        // so that [-60, 0] becomes initial center of projection
    maxlat = 83;        // clip northern and southern poles (infinite in mercator)

var projection = d3.geoMercator()
    .rotate([rotate,0])
    .scale(1)           // we'll scale up to match viewport shortly.
    .translate([width/2, height/2]);

// find the top left and bottom right of current projection
function mercatorBounds(projection, maxlat) {
    var yaw = projection.rotate()[0],
        xymax = projection([-yaw+180-1e-6,-maxlat]),
        xymin = projection([-yaw-180+1e-6, maxlat]);

    return [xymin,xymax];
}

// set up the scale extent and initial scale for the projection
var b = mercatorBounds(projection, maxlat),
    s = width/(b[1][0]-b[0][0]),
    scaleExtent = [s, 10*s];

projection
    .scale(scaleExtent[0]);

var zoom = d3.behavior.zoom()
    .scaleExtent(scaleExtent)
    .scale(projection.scale())
    .translate([0,0])               // not linked directly to projection
    .on("zoom", redraw);

var path = d3.geoPath()
    .projection(projection);

var svg = d3.selectAll('body')
    .append('svg')
        .attr('width',width)
        .attr('height',height)
        .call(zoom);

d3.json("world.json", function ready(error, world) {

    svg.selectAll('path')
        .data(topojson.feature(world, world.objects.countries).features)
      .enter().append('path')

    redraw();       // update path data
});

// track last translation and scale event we processed
var tlast = [0,0],
    slast = null;

function redraw() {
    if (d3.event) {
        var scale = d3.event.scale,
            t = d3.event.translate;

        // if scaling changes, ignore translation (otherwise touch zooms are weird)
        if (scale != slast) {
            projection.scale(scale);
        } else {
            var dx = t[0]-tlast[0],
                dy = t[1]-tlast[1],
                yaw = projection.rotate()[0],
                tp = projection.translate();

            // use x translation to rotate based on current scale
            projection.rotate([yaw+360.*dx/width*scaleExtent[0]/scale, 0, 0]);
            // use y translation to translate projection, clamped by min/max
            var b = mercatorBounds(projection, maxlat);
            if (b[0][1] + dy > 0) dy = -b[0][1];
            else if (b[1][1] + dy < height) dy = height-b[1][1];
            projection.translate([tp[0],tp[1]+dy]);
        }
        // save last values.  resetting zoom.translate() and scale() would
        // seem equivalent but doesn't seem to work reliably?
        slast = scale;
        tlast = t;
    }

    svg.selectAll('path')       // re-project path data
        .attr('d', path);
}


</script>
</body> -->